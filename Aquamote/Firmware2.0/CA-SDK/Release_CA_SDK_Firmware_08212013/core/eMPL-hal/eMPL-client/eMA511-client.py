#!/usr/bin/python# eMPL_client.py# A PC application for use with Embedded MotionApps.# Copyright 2012 InvenSense, Inc. All Rights Reserved.from __future__ import with_statementimport serial, sys, time, string, csv, structimport pygameimport osimport datetimefrom ponycube import *from struct import *if not os.path.exists('logs'):    os.makedirs('logs')f_file=''es_file=''c_file=''cf=''cfc=''esfc=''curr_light=0;count=0count_type=0set_total_1=0l=list()#all_sensors = Falselog_es=Falselog_c=Falselog=Falselog_accel= Falselog_gyro= Falselog_compass= Falselog_rotmatrix= Falselog_eular= Falselog_quat= Falselog_external_sensors= Falselog_heading= Falseaccel_enable= "Enable"gyro_enable= "Enable"compass_enable= "Enable"accel_enable_bool= Truegyro_enable_bool= Truecompass_enable_bool= Trueaccel_d_enable= "Disable"gyro_d_enable= "Disable"compass_d_enable= "Disable"euler_d_enable= "Disable"rotmat_d_enable= "Disable"heading_d_enable= "Disable"quat_d_enable= "Disable"exter_sensor_d_enable= "Disable"array_a=['x','x','x']array_g=['x','x','x']array_c=['x','x','x']array_q=['x','x','x','x']array_e=['x','x','x']array_rm=['x','x','x','x','x','x','x','x','x']array_h=['x']array_es=['x','x','x','x','x']## cnt=0;## save_key=[0,0,0,0];hal_header=[0,0,0,0]header = ["i","n","v"]hal_cmd =[0,0,0,0]class eMPL_packet_reader:        def __init__(self, port, quat_delegate=None, debug_delegate=None, data_delegate=None ):            self.s = serial.Serial(port,115200)           # self.s.setTimeout(0.1)            # self.s.setWriteTimeout(0.2)                           # TODO: Will this break anything?                ##Client attempts to write to eMPL.                #try:                #self.s.write('\n')                #except serial.serialutil.SerialTimeoutException:                #pass # write will timeout if umpl app is already started.            if quat_delegate:                self.quat_delegate = quat_delegate            else:                self.quat_delegate = empty_packet_delegate()            if debug_delegate:                self.debug_delegate = debug_delegate            else:                self.debug_delegate = empty_packet_delegate()            if data_delegate:                self.data_delegate = data_delegate            else:                self.data_delegate = empty_packet_delegate()            self.packets = []            self.length = 0            self.previous = None        def read(self):            NUM_BYTES = 23            p = None            while self.s.inWaiting() >= NUM_BYTES:                rs = self.s.read(NUM_BYTES)                if ord(rs[0]) == ord('$'):                    pkt_code = ord(rs[1])                    if pkt_code == 1:                        d = debug_packet(rs)                        self.debug_delegate.dispatch(d)                    elif pkt_code == 2:                        p = quat_packet(rs)                        self.quat_delegate.dispatch(p)                     elif pkt_code == 3:                        d = data_packet(rs)                        self.data_delegate.dispatch(d)                    else:                        sss = 'no handler for pkt_code',pkt_code                else:                    c = ' '                    sss = 'serial misaligned!'                    print (sss)                    while not ord(c) == ord('$'):                        c = self.s.read(1)                    self.s.read(NUM_BYTES-1)        def write(self,a):            self.s.write(a)        def close(self):            self.s.close()        def write_log(self,fname):            f = open(fname,'w')                        for p in self.packets:                f.write(p.logfile_line())            f.close()    # ===========  PACKET DELEGATES  ==========class packet_delegate(object):        def loop(self,event):            sss = 'generic packet_delegate loop w/event',event            print (sss)                            def dispatch(self,p):            sss = 'generic packet_delegate dispatched',p            print (sss)class empty_packet_delegate(packet_delegate):        def loop(self,event):            pass        def dispatch(self,p):            passclass cube_packet_viewer (packet_delegate):        def __init__(self):            self.screen = Screen(480,400,scale=1.5)            self.cube = Cube(30,60,10)            self.q = Quaternion(1,0,0,0)            self.previous = None  # previous quaternion            self.latest = None            def loop(self,event):            packet = self.latest            if packet:                q = packet.to_q().normalized()                self.cube.erase(self.screen)                self.cube.draw(self.screen,q)                pygame.display.flip()                self.latest = None        def dispatch(self,p):            if isinstance(p,quat_packet):                self.latest = p                        def close():            pygameclass debug_packet_viewer (packet_delegate):        def loop(self,event):            pass        def dispatch(self,p):            assert isinstance(p,debug_packet);            p.display()class data_packet_viewer (packet_delegate):        def loop(self,event):            pass        def dispatch(self,p):            assert isinstance(p,data_packet);            p.display()    # =============== PACKETS =================     # For 16-bit signed integers.def two_bytes(d1,d2):        d = ord(d1)*256 + ord(d2)        if d > 32767:            d -= 65536        return ddef two_bytes_no_check(d1, d2):        d = ord(d1)*256 + ord(d2)        return d            # For 32-bit signed integers.def four_bytes(d1, d2, d3, d4):        d = ord(d1)*(1<<24) + ord(d2)*(1<<16) + ord(d3)*(1<<8) + ord(d4)        if d > 2147483648:            d-= 4294967296        return dclass debug_packet (object):        # body of packet is a debug string        def __init__(self,l):            sss = []            for c in l[3:21]:                if ord(c) != 0:                    sss.append(c)            self.s = ''.join(sss)        def display(self):            sys.stdout.write(self.s)            class data_packet (object):        def __init__(self, l):            global curr_light;            self.data = [0,0,0,0,0,0,0,0,0]            self.type = ord(l[2])            if self.type == 0:   # accel                self.data[0] = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<16)                self.data[1] = four_bytes(l[7],l[8],l[9],l[10]) * 1.0 / (1<<16)                self.data[2] = four_bytes(l[11],l[12],l[13],l[14]) * 1.0 / (1<<16)                            elif self.type == 1:   # gyro                self.data[0] = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<16)                self.data[1] = four_bytes(l[7],l[8],l[9],l[10]) * 1.0 / (1<<16)                self.data[2] = four_bytes(l[11],l[12],l[13],l[14]) * 1.0 / (1<<16)                          elif self.type == 2:   # compass                self.data[0] = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<16)                self.data[1] = four_bytes(l[7],l[8],l[9],l[10]) * 1.0 / (1<<16)                self.data[2] = four_bytes(l[11],l[12],l[13],l[14]) * 1.0 / (1<<16)                         elif self.type == 3:   # quat                self.data[0] = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<30)                self.data[1] = four_bytes(l[7],l[8],l[9],l[10]) * 1.0 / (1<<30)                self.data[2] = four_bytes(l[11],l[12],l[13],l[14]) * 1.0 / (1<<30)                self.data[3] = four_bytes(l[15],l[16],l[17],l[18]) * 1.0 / (1<<30)            elif self.type == 4:   # euler                self.data[0] = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<16)                self.data[1] = four_bytes(l[7],l[8],l[9],l[10]) * 1.0 / (1<<16)                self.data[2] = four_bytes(l[11],l[12],l[13],l[14]) * 1.0 / (1<<16)                            elif self.type == 5:   # rot                self.data[0] = two_bytes(l[3],l[4]) * 1.0 / (1<<14)                self.data[1] = two_bytes(l[5],l[6]) * 1.0 / (1<<14)                self.data[2] = two_bytes(l[7],l[8]) * 1.0 / (1<<14)                self.data[3] = two_bytes(l[9],l[10]) * 1.0 / (1<<14)                self.data[4] = two_bytes(l[11],l[12]) * 1.0 / (1<<14)                self.data[5] = two_bytes(l[13],l[14]) * 1.0 / (1<<14)                self.data[6] = two_bytes(l[15],l[16]) * 1.0 / (1<<14)                self.data[7] = two_bytes(l[17],l[18]) * 1.0 / (1<<14)                self.data[8] = two_bytes(l[19],l[20]) * 1.0 / (1<<14)                            elif self.type == 6:   # heading                self.data[0] = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<16)            elif self.type == 7:                self.data[0] = two_bytes_no_check(l[3],l[4])  # Pressure                self.data[0] =  self.data[0] * 60 / 65535 + 50                self.data[0] =  self.data[0] * 10                                self.data[1] =  two_bytes_no_check(l[5],l[6]) # Humidity                s= struct.pack('f', self.data[1])                i= struct.unpack('i',s)                temp = struct.pack('f', 65528)                i_temp= struct.unpack('i',temp)                tm = ( i_temp[0] & i[0])                temp = struct.pack('i', tm)                i_temp= struct.unpack('f',temp)                self.data[1] =i_temp[0]                                self.data[1] = (float) (-6 + 125 * ( self.data[1]/ (2**16)));                                self.data[2] =  two_bytes_no_check(l[7],l[8]) # Temperature                self.data[2] = (float) (-46.85 + 175.72 * (self.data[2]/ (2.0**16.0)))                                        self.data[3] = two_bytes_no_check(l[9],l[10])# Light                self.data[3] = self.data[3] * (float) (0.06103) # for CM323						                curr_light = (self.data[3] * (float) (0.8)) + (curr_light * (float)(0.2))                curr_light = round(curr_light)                self.data[3] = curr_light;                                uv= two_bytes_no_check(l[11],l[12])                self.data[4] = (uv * (float)(0.022)) * 10; #UV                array_es[0]=self.data[0]                array_es[1]=self.data[1]                array_es[2]=self.data[2]                array_es[3]=self.data[3]                array_es[4]=self.data[4]            else:   # unsupported                pass        def display(self):            global f_file            global es_file            global c_file            global count            global count_type            global l            global log            global set_total_1            global array_a            global array_g            global array_c            global array_q            global array_e            global array_rm            global array_h            global array_es            global log_accel            global log_gyro            global log_compass            global log_rotmatrix            global log_eular            global log_quat            global log_external_sensors            global log_heading            global accel_d_enable            global gyro_d_enable            global compass_d_enable            global euler_d_enable            global rotmat_d_enable            global heading_d_enable            global quat_d_enable            global exter_sensor_d_enable                        millis = int(round(time.time() * 1000))                        if self.type == 0:                    accel_d_enable= "Enable"                    sss = 'accel: %7.3f %7.3f %7.3f' % \                          (self.data[0], self.data[1], self.data[2])                    print (sss)                                    count=count +1                    count_type= count_type+1;                    array_a[0]=self.data[0]                    array_a[1]=self.data[1]                    array_a[2]=self.data[2]             elif self.type == 1:                    gyro_d_enable= "Enable"                    sss = 'gyro: %9.5f %9.5f %9.5f' % \                          (self.data[0], self.data[1], self.data[2])                    print (sss)                    count=count +1                    array_g[0]=self.data[0]                    array_g[1]=self.data[1]                    array_g[2]=self.data[2]                                 elif self.type == 2:                    compass_d_enable= "Enable"                    sss = 'compass: %7.4f %7.4f %7.4f' % \                          (self.data[0], self.data[1], self.data[2])                    print (sss)                    count=count +1                    array_c[0]=self.data[0]                    array_c[1]=self.data[1]                    array_c[2]=self.data[2]                                 elif self.type == 3:                    quat_d_enable= "Enable"                    sss = 'quat: %7.4f %7.4f %7.4f %7.4f' % \                          (self.data[0], self.data[1], self.data[2], self.data[3])                    print (sss)                    count=count +1                    array_q[0]=self.data[0]                    array_q[1]=self.data[1]                    array_q[2]=self.data[2]                    array_q[3]=self.data[3]                                 elif self.type == 4:                    euler_d_enable= "Enable"                    sss = 'euler: %7.4f %7.4f %7.4f' % \                          (self.data[0], self.data[1], self.data[2])                    print (sss)                    count=count +1                    array_e[0]=self.data[0]                    array_e[1]=self.data[1]                    array_e[2]=self.data[2]             elif self.type == 5:                    rotmat_d_enable= "Enable"                    sss = 'rotation matrix: \n%7.3f %7.3f %7.3f\n%7.3f %7.3f %7.3f\n%7.3f %7.3f %7.3f' % \                          (self.data[0], self.data[1], self.data[2], self.data[3], \                           self.data[4], self.data[5], self.data[6], self.data[7], \                           self.data[8])                    print (sss)                    count=count +1                    array_rm[0]=self.data[0]                    array_rm[1]=self.data[1]                    array_rm[2]=self.data[2]                    array_rm[3]=self.data[3]                    array_rm[4]=self.data[4]                    array_rm[5]=self.data[5]                    array_rm[6]=self.data[6]                    array_rm[7]=self.data[7]                    array_rm[8]=self.data[8]                                elif self.type == 6:                    heading_d_enable= "Enable"                    sss = 'heading: %7.4f' % self.data[0]                    print (sss)                    count=count +1                    array_h[0]=self.data[0]                                                elif self.type == 7:                    exter_sensor_d_enable= "Enable"                    print ('Sensors (Pressure, Humidity, Temperature, Light, UV):\n %.2f %.2f %.2f %.2f %.2f' % \                           (array_es[0], array_es[1], array_es[2],array_es[3],array_es[4]))                          #(self.data[0], self.data[1], self.data[2],self.data[3],self.data[4]))                    count=count +1                                        if (log_es ==True):                        if(log_external_sensors  == True): #UV, TEMP, Pressure, Light, humidity in one file                            es_file.writerow(list([millis,array_es[0],array_es[1],array_es[2],array_es[3],array_es[4]]))                                else:                print ('what?')                            if (log ==True):                                       if(count >= set_total_1 and set_total_1>0):                    count=0                    l.extend([millis])                    if(log_accel ==True):                        l.extend([array_a[0],array_a[1],array_a[2]])                    if(log_gyro ==True):                        l.extend([array_g[0],array_g[1],array_g[2]])                    if(log_compass ==True):                        l.extend([array_c[0],array_c[1],array_c[2]])                    if(log_eular ==True):                        l.extend([array_e[0],array_e[1],array_e[2]])                    if(log_quat ==True):                        l.extend([array_q[0],array_q[1],array_q[2],array_q[3]])                                            if(log_rotmatrix ==True):                        l.extend([array_rm[0],array_rm[1],array_rm[2],array_rm[3],array_rm[4],array_rm[5],array_rm[6],array_rm[7],array_rm[8]])                                            if(log_heading ==True):                        l.extend([array_h[0]])                    f_file.writerow(list(l))                    del l[:]                                                                       class quat_packet (object):        def __init__(self, l):            self.l = l            self.q0 = four_bytes(l[3],l[4],l[5],l[6]) * 1.0 / (1<<30)            self.q1 = four_bytes(l[7],l[8],l[9],l[10]) * 1.0 / (1<<30)            self.q2 = four_bytes(l[11],l[12],l[13],l[14]) * 1.0 / (1<<30)            self.q3 = four_bytes(l[15],l[16],l[17],l[18]) * 1.0 / (1<<30)        def display_raw(self):                l = self.l                sss = ''.join(                            [ str(ord(l[0])), ' '] + \                            [ str(ord(l[1])), ' '] + \                            [ str(ord(a)).ljust(4) for a in                                                                     [ l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9], l[10] ] ] + \                            [ str(ord(a)).ljust(4) for a in                                                                     [ l[8], l[9], l[10] , l[11], l[12], l[13]] ]                )                print (sss)        def display(self):            if 1:                    sss = 'qs ' + ' '.join([str(s).ljust(15) for s in                                            [ self.q0, self.q1, self.q2, self.q3 ]])                    print (sss)            if 0:                euler0, euler1, euler2 = self.to_q().get_euler()                sss = 'eulers ' + ' '.join([str(s).ljust(15) for s in                                            [ euler0, euler1, euler2 ]])                print (sss)                                        if 0:                euler0, euler1, euler2 = self.to_q().get_euler()                sss = 'eulers ' + ' '.join([str(s).ljust(15) for s in                                            [ (euler0 * 180.0 / 3.14159) - 90 ]])                print (sss)        def to_q(self):            return Quaternion(self.q0, self.q1, self.q2, self.q3)def check_val(word):    global log_accel    global log_gyro    global log_compass    global log_rotmatrix    global log_eular    global log_quat    global log_external_sensors    global log_heading        global accel_d_enable    global gyro_d_enable    global compass_d_enable    global euler_d_enable    global rotmat_d_enable    global heading_d_enable    global quat_d_enable    global exter_sensor_d_enable        global accel_enable    global gyro_enable    global compass_enable    global accel_enable_bool    global gyro_enable_bool    global compass_enable_bool    global set_total_1    global set_total_2    if(word=='8'):        if(accel_enable_bool!=True):            print ('Enabled Accel!\n')            accel_enable= "Enable"            accel_enable_bool=True;        else:            accel_enable_bool=False;            accel_enable="Disable"            print ('Disabled Accel!\n')                if(word=='9'):        if(gyro_enable_bool!=True):            print ('Enabled Gyro!\n')            gyro_enable= "Enable"            gyro_enable_bool=True;        else:            gyro_enable_bool=False;            gyro_enable="Disable"            print ('Disabled Gyro!\n')                if(word=='0'):        if(compass_enable_bool!=True):            print ('Enabled Compass!\n')            compass_enable= "Enable"            compass_enable_bool=True;        else:            compass_enable_bool=False;            compass_enable="Disable"            print ('Disabled compass!\n')                if(word=='a'):        if(log_accel!=True):            print ('Logging enabled for Accel!\n')            accel_d_enable= "Enable"            set_total_1=set_total_1+1            log_accel=True;            #all_sensors=True        else:            log_accel=False;            accel_d_enable="Disable"            set_total_1=set_total_1-1            print ('Logging disabled for Accel!\n')                       elif(word=='g'):        if(log_gyro!=True):            print ('Logging enabled for Gyro\n')            gyro_d_enable= "Enable"            set_total_1=set_total_1+1            log_gyro=True;           # all_sensors=True        else:            log_gyro=False;            gyro_d_enable= "Disable"            set_total_1=set_total_1-1            print ('Logging disabled for Gyro!\n')            elif(word=='c'):        if(log_compass!=True):            print ('Logging enabled for Compass\n')            compass_d_enable= "Enable"            set_total_1 =set_total_1 + 1            log_compass=True;        else:            log_compass=False;            set_total_1 =set_total_1 - 1            compass_d_enable= "Disable"            print ('Logging disabled for Compass!\n')            elif(word=='e'):        if(log_eular != True):            print ('Logging enabled for Eular!\n')            euler_d_enable= "Enable"            log_eular=True;            set_total_1=set_total_1+1            #all_sensors=True        else:            log_eular=False;            euler_d_enable= "Disable"            set_total_1=set_total_1-1            print ('Logging disabled for Eular!\n')    elif(word=='r'):        if(log_rotmatrix != True):            print ('Logging enabled for Rotational Matrix!\n')            rotmat_d_enable= "Enable"            log_rotmatrix=True;            set_total_1=set_total_1+1            #all_sensors=True        else:            log_rotmatrix=False;            rotmat_d_enable= "Disable"            set_total_1=set_total_1-1            print ('Logging disabled for Rotational Matrix!\n')            elif(word=='h'):        if(log_heading != True):            print ('Logging enabled for Heading!\n')            heading_d_enable= "Enable"            log_heading=True;            set_total_1=set_total_1+1            #all_sensors=True        else:            log_heading=False;            heading_d_enable= "Disable"            set_total_1=set_total_1-1            print ('Logging disabled for Heading!\n')    elif(word=='q'):        if(log_quat != True):            print ('Logging enabled for Quaternion!\n')            quat_d_enable= "Enable"            log_quat=True;            set_total_1=set_total_1+1            #all_sensors=True        else:            log_quat=False;            set_total_1=set_total_1-1            quat_d_enable= "Disable"            print ('Logging disabled for Quaternion!\n')    elif(word=='k'):        if(log_external_sensors != True):            print ('Logging enabled for External Sensors!\n')            log_external_sensors=True;            exter_sensor_d_enable= "Enable"        else:            log_external_sensors=False;            exter_sensor_d_enable= "Disable"            print ('Logging disabled for External Sensors!\n')                elif(word =='x'):        erase_info()def start_menu():    global set_total_1    global accel_enable    global gyro_enable    global compass_enable    global accel_d_enable    global gyro_d_enable    global compass_d_enable    global euler_d_enable    global rotmat_d_enable    global heading_d_enable    global quat_d_enable    global exter_sensor_d_enable            print ("Welcome !!! Thanks for using invensense CA-SDK example\n")    print ("Version # of Application: eMA511-client\n")    print ("-----------------------------------------------------------")    print ("                   Start Menu\n")    print ("Type the command inv<> to toggle the feature status\n")    print ("-----------------------------------------------------------")    print ("Enable / Disable Features\n")    print ("---------------------------")    print ("Command         Feature          Feature Status\n")    print ("-------         -------           --------------\n")    print ("inv8             Accel            "+accel_enable+"\n")    print ("inv9             Gyro             "+gyro_enable+"\n")    print ("inv0             Compass          "+compass_enable+"\n")    print ("-----------------------------------------------------------")    print ("Enable / Disable Display\n")    print ("---------------------------")    print ("Command         Feature             Display Status\n")    print ("-------         -------             --------------\n")    print ("inva             Accel               "+accel_d_enable+"\n")    print ("invg             Gyro                "+gyro_d_enable+"\n")    print ("invc             Compass             "+compass_d_enable+"\n")    print ("inve             Euler               "+euler_d_enable+"\n")    print ("invr             Rotational Matrix   "+rotmat_d_enable+"\n")    print ("invh             Heading             "+heading_d_enable+"\n")    print ("invq             Quaternion          "+quat_d_enable+"\n")    print ("invk             Other Sensors       "+exter_sensor_d_enable+"\n")      print ("-----------------------------------------------------------")    print ("For file logging, Ctrl+s to start logging. Once file logging start,\n"           "Ctrl+t needs to be done to stop logging again to make changes to command\n"           "or enable/disbale features\n")    print ("-----------------------------------------------------------")    print ("invx            Reset\n")    print ("invn            eMA version\n")    print ("-----------------------------------------------------------")    def erase_info():        global accel_enable    global gyro_enable    global compass_enable    global accel_enable_bool    global gyro_enable_bool    global compass_enable_bool    global accel_d_enable    global gyro_d_enable    global compass_d_enable    global euler_d_enable    global rotmat_d_enable    global heading_d_enable    global quat_d_enable    global exter_sensor_d_enable    global log_es    global log    global log_accel    global log_gyro    global log_compass    global log_rotmatrix    global log_eular    global log_quat    global log_external_sensors    global log_heading    global cf    global esfc    global count    global count_type    global set_total_1    global array_a    global array_g    global array_c    global array_q    global array_e    global array_rm    global array_h    global array_es        accel_enable= "Enable"    gyro_enable= "Enable"    compass_enable= "Enable"    accel_enable_bool= True    gyro_enable_bool= True    compass_enable_bool= True    accel_d_enable= "Disable"    gyro_d_enable= "Disable"    compass_d_enable= "Disable"    euler_d_enable= "Disable"    rotmat_d_enable= "Disable"    heading_d_enable= "Disable"    quat_d_enable= "Disable"    exter_sensor_d_enable= "Disable"    print('Restaring...');    if(log ==True):        cf.close()    if(log_es  ==True):        esfc.close()    count=0    count_type=0    set_total_1=0    array_a=['x','x','x']    array_g=['x','x','x']    array_c=['x','x','x']    array_q=['x','x','x','x']    array_e=['x','x','x']    array_rm=['x','x','x','x','x','x','x','x','x']    array_h=['x']    array_es=['x','x','x','x','x']    log_es=False    log=False    log_accel= False    log_gyro= False    log_compass= False    log_rotmatrix= False    log_eular= False    log_quat= False    log_external_sensors= False    log_heading= False    start_menu()            # =============== MAIN ======================if __name__ == '__main__':            if len(sys.argv) == 2:                comport = sys.argv[1]        else:                print ('usage: ' + sys.argv[0] + ' port')                sys.exit(-1)                                      pygame.init()        viewer = cube_packet_viewer()        debug  = debug_packet_viewer()        data   = data_packet_viewer()        reader = eMPL_packet_reader(comport,                     quat_delegate = viewer,                     debug_delegate = debug,                     data_delegate = data)                    start_menu()                             while 1:            event = pygame.event.poll()            # TODO: Allow exit via keystroke.            if event.type == pygame.QUIT:                viewer.close()                break                                    if event.type == pygame.KEYDOWN:                if(log == True or log_es==True):                    c=(pygame.key.name(event.key))                    if (hal_header[0] == header[0]):                        if (hal_header[1] == header[1]):                                if (hal_header[2] == header[2]):                                    if( c == 'x'):                                        hal_header=[0,0,0]                                        check_val(c)                                elif (c == header[2]):                                    hal_header[2] = c;                                else:                                    hal_header=[0,0,0]                        elif (c == header[1]):                            hal_header[1] = c;                        else:                            hal_header=[0,0,0]                    elif (c == header[0]):                        hal_header[0] = header[0];                                            if event.key in( pygame.K_a , pygame.K_g, pygame.K_c, pygame.K_q,                                         pygame.K_e, pygame.K_r, pygame.K_h, pygame.K_k,                                         pygame.K_e, pygame.K_9, pygame.K_8, pygame.K_0):                        reader.write(pygame.key.name(pygame.K_n))                    else:                        reader.write(pygame.key.name(event.key))                    if ( pygame.key.get_mods()& pygame.KMOD_CTRL and event.key== pygame.K_t):                        print('closing the Logging..');                        if(log ==True):                            cf.close()                        if(log_es  ==True):                            esfc.close()                        log=False;                        log_es=False;                        print ('closed!')                        start_menu()                                    else:                    reader.write( (pygame.key.name(event.key)))                    c=(pygame.key.name(event.key))                    if (hal_header[0] == header[0]):                        if (hal_header[1] == header[1]):                                if (hal_header[2] == header[2]):                                    check_val(c)                                    hal_header=[0,0,0]                                elif (c == header[2]):                                    hal_header[2] = c;                                else:                                    hal_header=[0,0,0]                                                            elif (c == header[1]):                            hal_header[1] = c;                        else:                            hal_header=[0,0,0]                                                elif (c == header[0]):                        hal_header[0] = header[0];                                            if  ( pygame.key.get_mods()& pygame.KMOD_CTRL and event.key== pygame.K_s):                                                if(log_external_sensors  ==True):                            filename_es = 'logs/External_' + datetime.datetime.now().strftime('%m_%d_%Y_%H_%M_%S')                            esfc= open (filename_es+'.csv', 'w')                            es_file = csv.writer(esfc, delimiter=',')                            es_file.writerow(list(['Time','Pressure', 'Humidity', 'Temperature', 'Light', 'UV']))                            log_es=True;                            print ('Logging started! \n')                                                    if(set_total_1>0):                            filename = 'logs/all' + datetime.datetime.now().strftime('%m_%d_%Y_%H_%M_%S')                            cf= open (filename+'.csv', 'w')                            f_file = csv.writer(cf, delimiter=',')                            l.extend(['Time'])                            if(log_accel ==True):                                l.extend(['Accel[0]','Accel[1]','Accel[2]'])                            if(log_gyro ==True):                                l.extend(['Gyro[0]','Gyro[1]','Gyro[2]'])                            if(log_compass ==True):                                l.extend(['Compass[0]','Compass[1]','Compass[2]'])                            if(log_eular ==True):                                l.extend(['Eular[0]','Eular[1]','Eular[2]'])                            if(log_quat ==True):                                l.extend(['Quat[0]','Quat[1]','Quat[2]','Quat[3]'])                            if(log_rotmatrix ==True):                                l.extend(['Rot Matrix[0]','Rot Matrix[1]','Rot Matrix[2]','Rot Matrix[3]','Rot Matrix[4]',                                          'Rot Matrix[5]','Rot Matrix[6]','Rot Matrix[7]','Rot Matrix[8]'])                            if(log_heading ==True):                                l.extend(['Heading'])                                                        f_file.writerow(list(l))                            print ('Logging started! \n')                            del l[:]                            log=True;                                        reader.read()            viewer.loop(event)            debug.loop(event)            data.loop(event)            # TODO: If system load is too high, increase this sleep time.            pygame.time.delay(0)                 