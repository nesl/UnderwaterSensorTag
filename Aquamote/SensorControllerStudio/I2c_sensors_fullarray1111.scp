<?xml version="1.0"?>
<project name="I2C Sensors fullarray1111" version="1.4.1.54">
    <desc><![CDATA[]]></desc>
    <pattr name="Board">None</pattr>
    <pattr name="Chip name">CC2650</pattr>
    <pattr name="Chip package">QFN32 5x5 RHB</pattr>
    <pattr name="Chip revision">-</pattr>
    <pattr name="Code prefix"></pattr>
    <pattr name="Operating system">TI-RTOS</pattr>
    <pattr name="Output directory">C:/Users/EUN SUN LEE/Documents/Texas Instruments/Sensor Controller Studio/projects/I2c_sensors_fullarray - 1111</pattr>
    <task name="i2cimupressurewarray1111">
        <desc><![CDATA[]]></desc>
        <tattr name="ACCEL_CONFIG" type="hex" content="const" scope="task" min="0000" max="ffff">0014</tattr>
        <tattr name="ACCEL_SIZE" type="dec" content="const" scope="task" min="0" max="65535">30</tattr>
        <tattr name="ACCEL_XOUT_H" type="hex" content="const" scope="task" min="0000" max="ffff">002d</tattr>
        <tattr name="ArraySize8" type="hex" content="const" scope="task" min="0000" max="ffff">0008</tattr>
        <tattr name="BIN_COUNT" type="dec" content="const" scope="task" min="0" max="65535">10</tattr>
        <tattr name="CNTL2" type="hex" content="const" scope="task" min="0000" max="ffff">0031</tattr>
        <tattr name="GYRO_CONFIG_1" type="hex" content="const" scope="task" min="0000" max="ffff">0001</tattr>
        <tattr name="HXL" type="hex" content="const" scope="task" min="0000" max="ffff">0011</tattr>
        <tattr name="ICM_I2C_ADDR" type="hex" content="const" scope="task" min="0000" max="ffff">00d0</tattr>
        <tattr name="INT_PIN_CFG" type="hex" content="const" scope="task" min="0000" max="ffff">000f</tattr>
        <tattr name="MAG_I2C_ADDRESS" type="hex" content="const" scope="task" min="0000" max="ffff">0018</tattr>
        <tattr name="MS5837_ADC_READ" type="hex" content="const" scope="task" min="0000" max="ffff">0000</tattr>
        <tattr name="MS5837_CONV_D1_4096" type="hex" content="const" scope="task" min="0000" max="ffff">004a</tattr>
        <tattr name="MS5837_CONV_D2_4096" type="hex" content="const" scope="task" min="0000" max="ffff">0058</tattr>
        <tattr name="MS5837_I2C_ADDR" type="hex" content="const" scope="task" min="0000" max="ffff">00ec</tattr>
        <tattr name="MS5837_PROM" type="dec" content="const" scope="task" min="0" max="65535">160</tattr>
        <tattr name="MS5837_RESET" type="hex" content="const" scope="task" min="0000" max="ffff">001e</tattr>
        <tattr name="Onepagearray2048" type="hex" content="const" scope="task" min="0000" max="ffff">0800</tattr>
        <tattr name="PWR_MGMT_1" type="hex" content="const" scope="task" min="0000" max="ffff">0006</tattr>
        <tattr name="REG_MAGNETOMETER_ID" type="hex" content="const" scope="task" min="0000" max="ffff">0001</tattr>
        <tattr name="REG_MANUFACTURER_ID" type="hex" content="const" scope="task" min="0000" max="ffff">0000</tattr>
        <tattr name="REG_USERBANKSELECT" type="hex" content="const" scope="task" min="0000" max="ffff">007f</tattr>
        <tattr name="array100" type="hex" content="const" scope="task" min="0000" max="ffff">0064</tattr>
        <tattr name="array12" type="dec" content="const" scope="task" min="0" max="65535">12</tattr>
        <tattr name="array142" type="dec" content="const" scope="task" min="0" max="65535">142</tattr>
        <tattr name="array284" type="dec" content="const" scope="task" min="0" max="65535">284</tattr>
        <tattr name="array300" type="hex" content="const" scope="task" min="0000" max="ffff">012c</tattr>
        <tattr name="array50" type="dec" content="const" scope="task" min="0" max="65535">50</tattr>
        <tattr name="array500" type="hex" content="const" scope="task" min="0000" max="ffff">01f4</tattr>
        <tattr name="array512" type="hex" content="const" scope="task" min="0000" max="ffff">0200</tattr>
        <tattr name="array6" type="dec" content="const" scope="task" min="0" max="65535">6</tattr>
        <tattr name="array60" type="dec" content="const" scope="task" min="0" max="65535">60</tattr>
        <tattr name="array7" type="dec" content="const" scope="task" min="0" max="65535">7</tattr>
        <tattr name="array70" type="dec" content="const" scope="task" min="0" max="65535">70</tattr>
        <tattr name="array90" type="dec" content="const" scope="task" min="0" max="65535">90</tattr>
        <tattr name="input.prom" type="hex" content="struct" scope="task" min="0000" max="ffff">00a0</tattr>
        <tattr name="input.testval" type="hex" content="struct" scope="task" min="0000" max="ffff">dddd</tattr>
        <tattr name="output.pressureinit" size="array7" type="hex" content="struct_array" scope="task" min="0000" max="ffff">0000</tattr>
        <tattr name="output.result" size="array142" type="hex" content="struct_array" scope="task" min="0000" max="ffff">0000</tattr>
        <tattr name="output.tempresult" size="array12" type="hex" content="struct_array" scope="task" min="0000" max="ffff">0000</tattr>
        <tattr name="state.count1" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.magcount" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ncount" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.outputcount" type="dec" content="struct" scope="task" min="0" max="65535">49</tattr>
        <tattr name="state.pressurecount" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.prom" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.timecount" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <resource_ref name="ADC" enabled="0"/>
        <resource_ref name="Analog Open-Drain Pins" enabled="0"/>
        <resource_ref name="Analog Open-Source Pins" enabled="0"/>
        <resource_ref name="Analog Pins" enabled="0"/>
        <resource_ref name="COMPA" enabled="0"/>
        <resource_ref name="COMPB" enabled="0"/>
        <resource_ref name="COMPB Event Trigger" enabled="0"/>
        <resource_ref name="Delay Insertion" enabled="0"/>
        <resource_ref name="Differential Output Pins" enabled="0"/>
        <resource_ref name="Digital Input Pins" enabled="0"/>
        <resource_ref name="Digital Open-Drain Pins" enabled="0"/>
        <resource_ref name="Digital Open-Source Pins" enabled="0"/>
        <resource_ref name="Digital Output Pins" enabled="0"/>
        <resource_ref name="GPIO Event Trigger" enabled="0"/>
        <resource_ref name="I2C Master" enabled="1">
            <rattr name="SCL frequency">0</rattr>
            <rattr name="SCL stretch timeout">10</rattr>
            <io_usage>
                <uattr name="SCL pin/0000">DIO3</uattr>
                <uattr name="SDA pin/0000">DIO2</uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="ISRC" enabled="0"/>
        <resource_ref name="Math and Logic" enabled="0"/>
        <resource_ref name="Multi-Buffered Output Data Exchange" enabled="0">
            <rattr name="Buffer count">2</rattr>
            <rattr name="Indicate overflow at buffer check">1</rattr>
            <rattr name="Indicate overflow at buffer switch">0</rattr>
            <rattr name="Prevent overflow at buffer switch">1</rattr>
        </resource_ref>
        <resource_ref name="Peripheral Sharing" enabled="0"/>
        <resource_ref name="Pulse Counter" enabled="0"/>
        <resource_ref name="RTC Multi-Event Capture" enabled="0"/>
        <resource_ref name="RTC-Based Execution Scheduling" enabled="1"/>
        <resource_ref name="SPI Chip Select" enabled="0"/>
        <resource_ref name="SPI Data Transfer" enabled="0">
            <rattr name="Bit rate">0</rattr>
            <rattr name="MISO configuration when inactive">-1</rattr>
            <rattr name="MOSI configuration on initialization">0</rattr>
            <rattr name="MOSI configuration on uninitialization">0</rattr>
            <rattr name="SCLK configuration on initialization">0</rattr>
            <rattr name="SCLK configuration on uninitialization">0</rattr>
            <io_usage>
                <uattr name="MISO pin/0000"></uattr>
                <uattr name="MOSI pin/0000"></uattr>
                <uattr name="SCLK pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="System CPU Alert" enabled="1"/>
        <resource_ref name="TDC" enabled="0"/>
        <resource_ref name="Timer 0" enabled="0"/>
        <resource_ref name="Timer Event Trigger" enabled="0"/>
        <resource_ref name="UART Emulator" enabled="0">
            <rattr name="RX buffer size">64</rattr>
            <rattr name="Required idle period before enabling RX">11</rattr>
            <rattr name="TX buffer size">64</rattr>
            <io_usage>
                <uattr name="RX pin/0000"></uattr>
                <uattr name="TX pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <sccode name="event0"><![CDATA[]]></sccode>
        <sccode name="execute"><![CDATA[U16 n = state.ncount;
//Should record zero and 20 alternatively everytime
if(n == 0){
    output.result[n] = state.timecount;
    n = n+1;
}

//if(n >49){
//    n = 0;
//    fwGenAlertInterrupt();
//}
state.timecount = state.timecount + 1;
if(state.timecount > 39){
    state.timecount = 0;
}
i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(ACCEL_XOUT_H);

i2cRepeatedStart();
i2cTx(I2C_OP_READ | ICM_I2C_ADDR);

//TODO: testing this part as for loop
//while
//i2cRxAck(output.tempresult[0]);
i2cRxAck(output.tempresult[0]);
i2cRxAck(output.tempresult[1]);
i2cRxAck(output.tempresult[2]);
i2cRxAck(output.tempresult[3]);
i2cRxAck(output.tempresult[4]);
i2cRxAck(output.tempresult[5]);


output.result[n] = (output.tempresult[0] <<8) | output.tempresult[1];
n = n+1;
output.result[n] = (output.tempresult[2] <<8) | output.tempresult[3];
n = n+1;
output.result[n] = (output.tempresult[4] <<8) | output.tempresult[5];
n = n+1;

i2cRxAck(output.tempresult[0]);
i2cRxAck(output.tempresult[1]);
i2cRxAck(output.tempresult[2]);
i2cRxAck(output.tempresult[3]);
i2cRxAck(output.tempresult[4]);
i2cRxNack(output.tempresult[5]);

output.result[n] = (output.tempresult[0] <<8) | output.tempresult[1];
n = n+1;
output.result[n] = (output.tempresult[2] <<8) | output.tempresult[3];
n = n+1;
output.result[n] = (output.tempresult[4] <<8) | output.tempresult[5];
n = n+1;
i2cStop();

state.magcount = state.magcount+1;
if(state.magcount == 4){
    state.magcount = 0;
    //Read Data
    i2cStart();
    i2cTx(I2C_OP_WRITE | MAG_I2C_ADDRESS);
    i2cTx(HXL);

    i2cRepeatedStart();
    i2cTx(I2C_OP_READ | MAG_I2C_ADDRESS);

    i2cRxAck(output.tempresult[0]);
    i2cRxAck(output.tempresult[1]);
    i2cRxAck(output.tempresult[2]);
    i2cRxAck(output.tempresult[3]);
    i2cRxAck(output.tempresult[4]);
    i2cRxAck(output.tempresult[5]);

    //i2cRxAck(output.tempresult[0]);
    //i2cRxNack(output.tempresult[1]);

    output.result[n] = (output.tempresult[0] <<8) | output.tempresult[1];
    n = n+1;
    output.result[n] = (output.tempresult[2] <<8) | output.tempresult[3];
    n = n+1;
    output.result[n] = (output.tempresult[4] <<8) | output.tempresult[5];
    n = n+1;
    i2cStop();
}

state.pressurecount = state.pressurecount +1;
if(state.pressurecount == 10){
    state.pressurecount = 0;
    //start of pressure sensor
    //Request D1 Conversion
    i2cStart();
    i2cTx(I2C_OP_WRITE | MS5837_I2C_ADDR);
    i2cTx(MS5837_CONV_D1_4096);
    i2cStop();


    //TODO: probably not want it so test pressure sensor without while
    //timeout changes the status?

    state.count1 = 1;
    while(state.count1 > 0){
        state.count1 = state.count1 +1;
        if(state.i2cStatus == 0x0001){
            state.count1 = 0;
        }
    }

    i2cStart();
    i2cTx(I2C_OP_WRITE | MS5837_I2C_ADDR);
    i2cTx(MS5837_ADC_READ);
    i2cStop();


    //TODO: probably not want it so test pressure sensor without while
    //timeout changes the status?

    state.count1= 1;
    while(state.count1 >0){
        state.count1 = state.count1+1;
        if(state.i2cStatus == 0x0001){
            state.count1 = 0;
        }
    }

    i2cStart();
    i2cTx(I2C_OP_READ | MS5837_I2C_ADDR);
    i2cRxAck(output.tempresult[0]);
    i2cRxAck(output.tempresult[1]);
    i2cRxNack(output.tempresult[2]);
    i2cStop();
    //end of pressure sensor

    //start of temperature sensor
    //Request D2 Conversion
    i2cStart();
    i2cTx(I2C_OP_WRITE | MS5837_I2C_ADDR);
    i2cTx(MS5837_CONV_D2_4096);
    i2cStop();


    //TODO: probably not want it so test pressure sensor without while
    //timeout changes the status?
    state.count1 = 1;
    while(state.count1 > 0){
        state.count1 = state.count1 +1;
        if(state.i2cStatus == 0x0001){
            state.count1 = 0;
        }
    }

    i2cStart();
    i2cTx(I2C_OP_WRITE | MS5837_I2C_ADDR);
    i2cTx(MS5837_ADC_READ);
    i2cStop();


    //TODO: probably not want it so test pressure sensor without while
    //timeout changes the status?

    state.count1= 1;
    while(state.count1 >0){
        state.count1 = state.count1+1;
        if(state.i2cStatus == 0x0001){
            state.count1 = 0;
        }
    }

    i2cStart();
    i2cTx(I2C_OP_READ | MS5837_I2C_ADDR);
    i2cRxAck(output.tempresult[3]);
    i2cRxAck(output.tempresult[4]);
    i2cRxNack(output.tempresult[5]);

    output.result[n] = (output.tempresult[0] <<8) | output.tempresult[1];
    n = n+1;
    output.result[n] = (output.tempresult[2] <<8) | output.tempresult[3];
    n = n+1;
    output.result[n] = (output.tempresult[4] <<8) | output.tempresult[5];
    n = n+1;
    i2cStop();
}
state.ncount = n;
if(state.ncount >=142){
    state.ncount = 0;
    fwGenAlertInterrupt();
}



//state.count+ = 3;
//if (state.count >= 30){
//    state.count = 0;
//    fwGenAlertInterrupt();
//}
fwScheduleTask(1);]]></sccode>
        <sccode name="initialize"><![CDATA[U16 ManufacturerIdLow;

// Reg Bank Select
i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(REG_USERBANKSELECT);
i2cTx(0x00);
i2cStop();

// Reset
i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(PWR_MGMT_1);
i2cTx(0x01);
i2cStop();

//Enabling Bypass
i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(INT_PIN_CFG);
i2cTx(0x02);
i2cStop();

// Read the Magnetometer Manufacturer ID
//i2cStart();
//i2cTx(I2C_OP_WRITE | MAG_I2C_ADDRESS);
//i2cTx(REG_MAGNETOMETER_ID);
//i2cRepeatedStart();
//i2cTx(I2C_OP_READ | MAG_I2C_ADDRESS);
//i2cRxNack(ManufacturerIdLow);
//output.magId = ManufacturerIdLow;
//i2cStop();

//Continuous Mode
i2cStart();
i2cTx(I2C_OP_WRITE | MAG_I2C_ADDRESS);
i2cTx(CNTL2);
i2cTx(0x08);
i2cStop();

// Read the Manufacturer ID
//i2cStart();
//i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
//i2cTx(REG_MANUFACTURER_ID);
//i2cRepeatedStart();
//i2cTx(I2C_OP_READ | ICM_I2C_ADDR);
//i2cRxNack(ManufacturerIdLow);
//output.manuId = ManufacturerIdLow;
//i2cStop();

//Setup
i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(REG_USERBANKSELECT);
i2cTx(0x20);
i2cStop();

i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(ACCEL_CONFIG);
i2cTx(0x02);    //TODO sensitivity changes by this value
i2cStop();

i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(GYRO_CONFIG_1);
i2cTx(0x02); //0x00: 250 dps, 0x02: 500 dps, 0x04: 1000 dps, 0x06: 2000 dps
i2cStop();

// Reg Bank Select
i2cStart();
i2cTx(I2C_OP_WRITE | ICM_I2C_ADDR);
i2cTx(REG_USERBANKSELECT);
i2cTx(0x00);
i2cStop();

//Presssure Sensor

i2cStart();
i2cTx(I2C_OP_WRITE | MS5837_I2C_ADDR);
i2cTx(MS5837_RESET);
i2cStop();

for(U16 n = 0;n <7;n++){
    i2cStart();
    i2cTx(I2C_OP_WRITE | MS5837_I2C_ADDR);
    i2cTx(MS5837_PROM + state.prom);
    i2cStop();
    i2cStart();
    i2cTx(I2C_OP_READ | MS5837_I2C_ADDR);
    i2cRxAck(output.tempresult[0]);
    i2cRxNack(output.tempresult[1]);
    i2cStop();
    output.pressureinit[n] = (output.tempresult[0] <<8) | output.tempresult[1];
    state.prom = 2+state.prom;

}

//fwGenAlertInterrupt();


//TODO: output this data

// Schedule the first execution
fwScheduleTask(1);]]></sccode>
        <sccode name="terminate"><![CDATA[]]></sccode>
        <tt_iter>run_execute</tt_iter>
        <tt_struct>output.result.[139],output.result.[140],output.result.[141],output.tempresult.[10],output.tempresult.[11]</tt_struct>
    </task>
</project>
